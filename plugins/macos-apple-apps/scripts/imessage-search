#!/bin/bash
# imessage-search - Advanced iMessage search with attributedBody support
# Searches complete message history by decoding binary plist format

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
VENV_DIR="${SCRIPT_DIR}/.imessage-search-env"
PYTHON_SCRIPT="${SCRIPT_DIR}/.imessage-search.py"

show_help() {
  cat <<EOF
Usage: imessage-search [OPTIONS]

Advanced iMessage search that decodes attributedBody BLOB fields to search
complete message history (not just messages with plain text).

Search Modes:
  --felicitations          Search for birthday, holiday, congratulations messages
  --pattern "TEXT"         Search for custom pattern (case-insensitive)
  --keywords "W1,W2,..."   Search for multiple keywords (comma-separated)

Options:
  -o, --output FILE        Save results to file (default: stdout)
  -j, --json               Output as JSON
  -l, --limit N            Limit results to N contacts (default: unlimited)
  --csv                    Output as CSV with breakdown
  -h, --help               Show this help message

Examples:
  imessage-search --felicitations                 # Find all felicitation messages
  imessage-search --pattern "lunch"               # Find messages about lunch
  imessage-search --keywords "meeting,call"       # Find meeting/call related
  imessage-search --felicitations --csv -o ~/Desktop/contacts.csv

Notes:
  • First run will create virtual environment and install dependencies
  • Searches all historical messages (not just recent)
  • Decodes modern iMessage attributedBody format
  • Groups results by contact with message counts

Exit codes:
  0    Success
  1    Messages database not found
  2    Error during search
  3    Missing required dependencies
EOF
}

# Setup virtual environment on first run
setup_venv() {
    if [[ ! -d "$VENV_DIR" ]]; then
        echo "First run: Setting up virtual environment..." >&2
        uv venv "$VENV_DIR" >&2
        uv pip install --python "$VENV_DIR/bin/python" biplist >&2
        echo "Setup complete!" >&2
    fi
}

# Create Python helper script if it doesn't exist
create_python_script() {
    if [[ ! -f "$PYTHON_SCRIPT" ]]; then
        cat > "$PYTHON_SCRIPT" << 'PYTHON_EOF'
#!/usr/bin/env python3
"""iMessage search with attributedBody BLOB decoding support."""

import sqlite3
import os
import sys
import json
import biplist
import re
from datetime import datetime

def extract_text_from_attributedBody(attributed_body_blob):
    """Extract plain text from attributedBody BLOB (binary plist)."""
    if not attributed_body_blob:
        return None

    try:
        plist_data = biplist.readPlistFromString(attributed_body_blob)

        if isinstance(plist_data, dict):
            for key in ['NSString', 'NS.string', '$objects']:
                if key in plist_data:
                    value = plist_data[key]
                    if isinstance(value, str):
                        return value
                    elif isinstance(value, list):
                        for obj in value:
                            if isinstance(obj, str) and len(obj) > 0 and obj != '$null':
                                return obj
        elif isinstance(plist_data, str):
            return plist_data
    except:
        try:
            text = attributed_body_blob.decode('utf-8', errors='ignore')
            text = re.sub(r'[\x00-\x08\x0b-\x0c\x0e-\x1f]', '', text)
            if len(text.strip()) > 0:
                return text.strip()
        except:
            pass

    return None

def search_messages(keywords, limit=None):
    """Search messages for keywords and group by contact."""
    db_path = os.path.expanduser('~/Library/Messages/chat.db')

    if not os.path.exists(db_path):
        print(f"Error: Messages database not found at {db_path}", file=sys.stderr)
        sys.exit(1)

    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()

    query = """
    SELECT
        m.ROWID,
        m.text,
        m.attributedBody,
        h.id as contact,
        datetime(m.date/1000000000 + strftime('%s', '2001-01-01'), 'unixepoch', 'localtime') as date
    FROM message m
    JOIN handle h ON m.handle_id = h.ROWID
    WHERE m.is_from_me = 1
    ORDER BY m.date DESC
    """

    cursor.execute(query)

    contacts = {}

    for row in cursor:
        rowid, text, attributed_body, contact, date = row

        message_text = text
        if not message_text and attributed_body:
            message_text = extract_text_from_attributedBody(attributed_body)

        if not message_text:
            continue

        message_text_lower = message_text.lower()

        found_keywords = []
        for keyword in keywords:
            if keyword.lower() in message_text_lower:
                found_keywords.append(keyword)

        if found_keywords:
            if contact not in contacts:
                contacts[contact] = {
                    'count': 0,
                    'keywords': set(),
                    'last_date': None,
                    'messages': []
                }

            contacts[contact]['count'] += 1
            contacts[contact]['keywords'].update(found_keywords)
            if not contacts[contact]['last_date'] or date > contacts[contact]['last_date']:
                contacts[contact]['last_date'] = date

            if len(contacts[contact]['messages']) < 3:
                contacts[contact]['messages'].append({
                    'date': date,
                    'text': message_text[:100],
                    'keywords': found_keywords
                })

    conn.close()

    sorted_contacts = sorted(contacts.items(), key=lambda x: x[1]['count'], reverse=True)

    if limit:
        sorted_contacts = sorted_contacts[:limit]

    return sorted_contacts

def main():
    import argparse

    parser = argparse.ArgumentParser(description='Advanced iMessage search', add_help=False)
    parser.add_argument('--felicitations', action='store_true')
    parser.add_argument('--pattern')
    parser.add_argument('--keywords')
    parser.add_argument('-o', '--output')
    parser.add_argument('-j', '--json', action='store_true')
    parser.add_argument('--csv', action='store_true')
    parser.add_argument('-l', '--limit', type=int)
    parser.add_argument('-h', '--help', action='store_true')

    args = parser.parse_args()

    if args.help:
        return

    if args.felicitations:
        keywords = [
            'happy birthday', 'merry christmas', 'happy new year',
            'congratulations', 'congrats', 'happy thanksgiving',
            'happy easter', 'happy holidays', 'seasons greetings',
            'best wishes', 'happy anniversary'
        ]
    elif args.pattern:
        keywords = [args.pattern]
    elif args.keywords:
        keywords = [k.strip() for k in args.keywords.split(',')]
    else:
        print("Error: Must specify --felicitations, --pattern, or --keywords", file=sys.stderr)
        sys.exit(2)

    results = search_messages(keywords, args.limit)

    if not results:
        print("No matches found.")
        return

    output_lines = []

    if args.json:
        data = {
            'count': len(results),
            'contacts': [
                {
                    'contact': contact,
                    'message_count': data['count'],
                    'last_sent': data['last_date'],
                    'keywords': list(data['keywords'])
                }
                for contact, data in results
            ]
        }
        output_lines.append(json.dumps(data, indent=2))
    elif args.csv:
        output_lines.append('contact,count,last_sent,keywords')
        for contact, data in results:
            keywords_str = ';'.join(sorted(data['keywords']))
            output_lines.append(f'"{contact}",{data["count"]},"{data["last_date"]}","{keywords_str}"')
    else:
        output_lines.append(f"Found {len(results)} contacts:\n")
        output_lines.append(f"{'Contact':<40} {'Count':<8} {'Last Sent':<20} {'Keywords'}")
        output_lines.append("=" * 120)
        for contact, data in results:
            keywords_str = ', '.join(sorted(data['keywords']))[:40]
            output_lines.append(f"{contact:<40} {data['count']:<8} {data['last_date']:<20} {keywords_str}")

    output = '\n'.join(output_lines)

    if args.output:
        with open(args.output, 'w') as f:
            f.write(output)
        print(f"Results saved to: {args.output}")
    else:
        print(output)

if __name__ == '__main__':
    main()
PYTHON_EOF
        chmod +x "$PYTHON_SCRIPT"
    fi
}

# Parse arguments
if [[ $# -eq 0 ]] || [[ "$1" == "-h" ]] || [[ "$1" == "--help" ]]; then
    show_help
    exit 0
fi

# Setup environment
setup_venv
create_python_script

# Run the Python script
exec "$VENV_DIR/bin/python" "$PYTHON_SCRIPT" "$@"
